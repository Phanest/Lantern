'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; // see ./browser/jsdom.js for browser version
// see ./browser/xmldom.js for browser version


exports.default = jsonldRdfaParser;

var _graphRdfaProcessor = require('graph-rdfa-processor');

var _graphRdfaProcessor2 = _interopRequireDefault(_graphRdfaProcessor);

var _jsdom = require('jsdom');

var _jsdom2 = _interopRequireDefault(_jsdom);

var _xmldom = require('xmldom');

var _isUrl = require('is-url');

var _isUrl2 = _interopRequireDefault(_isUrl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';
var RDF_XML_LITERAL = RDF + 'XMLLiteral';
var RDF_HTML_LITERAL = RDF + 'HTML';
var RDF_OBJECT = RDF + 'object';
var RDF_PLAIN_LITERAL = RDF + 'PlainLiteral';
var RDF_LANGSTRING = RDF + 'langString';
var XSD_STRING = 'http://www.w3.org/2001/XMLSchema#string';

/**
 * @param data - a filePath, HTML string or URL
 */
function jsonldRdfaParser(data, callback) {
  if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && 'nodeType' in data) {
    process(data);
  } else if (typeof data === 'string') {
    var config = {
      done: function done(err, window) {
        if (err) return callback(err);
        process(window.document);
      }
    };
    if ((0, _isUrl2.default)(data)) config.url = data;else if (/<[a-z][\s\S]*>/i.test(data)) config.html = data;else config.file = data;
    _jsdom2.default.env(config);
  } else {
    return callback(new Error('data must be a file path, HTML string, URL or a DOM element'));
  }

  function process(node) {
    var opts = void 0;
    if (!node.baseURI || node.baseURI === 'about:blank') {
      opts = { baseURI: 'http://localhost/' };
    }

    var dataset = void 0,
        processingError = void 0;
    try {
      var graph = (0, _graphRdfaProcessor2.default)(node, opts);
      dataset = processGraph(graph);
    } catch (e) {
      processingError = e;
    }
    callback(processingError, dataset);
  }
}

/**
 * This function is mostly taken from the jsonld.js lib but updated to
 * the latest green-turtle API, and for support for HTML
 */
function processGraph(data) {
  var dataset = {
    '@default': []
  };

  var subjects = data.subjects,
      htmlMapper = function htmlMapper(n) {
    var div = n.ownerDocument.createElement('div');
    div.appendChild(n.cloneNode(true));
    return div.innerHTML;
  };
  Object.keys(subjects).forEach(function (subject) {
    var predicates = subjects[subject].predicates;
    Object.keys(predicates).forEach(function (predicate) {
      // iterate over objects
      var objects = predicates[predicate].objects;
      for (var oi = 0; oi < objects.length; ++oi) {
        var object = objects[oi];

        // create RDF triple
        var triple = {};

        // add subject & predicate
        triple.subject = {
          type: subject.indexOf('_:') === 0 ? 'blank node' : 'IRI',
          value: subject
        };
        triple.predicate = {
          type: predicate.indexOf('_:') === 0 ? 'blank node' : 'IRI',
          value: predicate
        };
        triple.object = {};

        // serialize XML literal
        var value = object.value;
        // !!! TODO: !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // The below actually most likely does NOT work.
        // In most usage contexts this will be an HTML DOM, passing it to xmldom's XMLSerializer
        // will cause it to call .toString() on all the nodes it finds â€” this only works inside
        // xmldom.
        if (object.type === RDF_XML_LITERAL) {
          (function () {
            // initialize XMLSerializer
            var serializer = new _xmldom.XMLSerializer();
            value = Array.from(object.value).map(function (n) {
              return serializer.serializeToString(n);
            }).join('');
            triple.object.datatype = RDF_XML_LITERAL;
          })();
        }
        // serialise HTML literal
        else if (object.type === RDF_HTML_LITERAL) {
            value = Array.from(object.value).map(htmlMapper).join('');
            triple.object.datatype = RDF_HTML_LITERAL;
          }
          // object is an IRI
          else if (object.type === RDF_OBJECT) {
              if (object.value.indexOf('_:') === 0) triple.object.type = 'blank node';else triple.object.type = 'IRI';
            } else {
              // object is a literal
              triple.object.type = 'literal';
              if (object.type === RDF_PLAIN_LITERAL) {
                if (object.language) {
                  triple.object.datatype = RDF_LANGSTRING;
                  triple.object.language = object.language;
                } else {
                  triple.object.datatype = XSD_STRING;
                }
              } else {
                triple.object.datatype = object.type;
              }
            }
        triple.object.value = value;

        // add triple to dataset in default graph
        dataset['@default'].push(triple);
      }
    });
  });

  return dataset;
}
module.exports = exports['default'];